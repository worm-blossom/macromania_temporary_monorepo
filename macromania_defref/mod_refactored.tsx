import { getNameAndDebug } from "../macromania_names_id/mod.tsx";
import {
  addName,
  dependencyJs,
  hrefToName,
  IdA,
  previewScopeDependencyJs,
  registerPreview,
} from "./deps.ts";
import { Expressions } from "./deps.ts";
import { hrefTo } from "./deps.ts";
import { dependencyCss } from "./deps.ts";
import { getPreviewPath } from "./deps.ts";
import { absoluteOutFsPath } from "./deps.ts";
import { previewScopeDependencyCss } from "./deps.ts";
import { PreviewScope } from "./deps.ts";
import { MData, MId } from "./deps.ts";
import { MClass } from "./deps.ts";
import { MHref } from "./deps.ts";
import { Dfn } from "./deps.ts";
import {
  A,
  Colors,
  Context,
  createConfigOptions,
  createLogger,
  createNamespace,
  Expression,
  isMathMode,
  M,
  ScriptDependencyInfo,
  styleDebuggingInformation,
  styleName,
  StylesheetDependencyInfo,
} from "./deps.ts";

const l = createLogger("LoggerDefref");
const ConfigMacro = l.ConfigMacro;
export { ConfigMacro as LoggerDefref };

/**
 * Configuration options for DefRef.
 */
export type DefrefConfig = {
  /**
   * An optional function for automatically constructing beginning-of-sentence versions of references.
   *
   * Defaults to rather naive capitalization without any locale-specific features.
   */
  defaultB?: ((ctx: Context, evaledR: string) => Expression) | null;
  /**
   * An optional function for automatically constructing plural versions of references.
   */
  defaultP?: ((ctx: Context, evaledR: string) => Expression) | null;
  /**
   * Css dependencies to add in all files that use a `<Def/>` macro.
   */
  depsCssDef?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add in all files that use a `<Def/>` macro.
   */
  depsJsDef?: ScriptDependencyInfo[];
  /**
   * Css dependencies to add in all files that use a referencing macro.
   */
  depsCssRef?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add in all files that use a referencing macro.
   */
  depsJsRef?: ScriptDependencyInfo[];
  /**
   * Css dependencies to add to all preview pages generated by a `<Def/>` macro.
   */
  depsCssPreview?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add to all preview pages generated by a `<Def/>` macro.
   */
  depsJsPreview?: ScriptDependencyInfo[];
};

const [getConfig, ConfigDefref] = createConfigOptions<
  DefrefConfig,
  DefrefConfig
>("ConfigDefref", () => ({
  defaultB: (_ctx, evaledR) =>
    `${evaledR.charAt(0).toUpperCase()}${evaledR.slice(1)}`,
  defaultP: null,
}), (old, update) => {
  const newValue: DefrefConfig = {
    defaultB: update.defaultB === undefined ? old.defaultB : update.defaultB,
    defaultP: update.defaultP === undefined ? old.defaultP : update.defaultP,
    depsCssDef: update.depsCssDef === undefined
      ? old.depsCssDef
      : update.depsCssDef,
    depsJsDef: update.depsJsDef === undefined
      ? old.depsJsDef
      : update.depsJsDef,
    depsCssRef: update.depsCssRef === undefined
      ? old.depsCssRef
      : update.depsCssRef,
    depsJsRef: update.depsJsRef === undefined
      ? old.depsJsRef
      : update.depsJsRef,
    depsCssPreview: update.depsCssPreview === undefined
      ? old.depsCssPreview
      : update.depsCssPreview,
    depsJsPreview: update.depsJsPreview === undefined
      ? old.depsJsPreview
      : update.depsJsPreview,
  };

  return newValue;
});
export { ConfigDefref };

const defs = createNamespace<DefInfo>("Defref Defs");

/**
 * The information to associate with each def.
 */
type DefInfo = {
  /**
   * The Expression to which the `<R/>` macro should expand for this def.
   *
   * Defaults to `n`.
   */
  r?: Expression;
  /**
   * The Expression to which the `<R/>` macro should expand for this def when the `b` flag is set. Intended to specify how to render references at the beginning of sentences.
   */
  rb?: Expression;
  /**
   * The Expression to which the `<R/>` macro should expand for this def when the `p` flag is set. Intended to specify how to render plural form references.
   */
  rp?: Expression;
  /**
   * The Expression to which the `<Rsb/>` macro should expand for this def when both the `b` and the `p` flag are set.
   */
  rpb?: Expression;
  /**
   * If true, all references will be wrapped in the `<EnsureMath>` macro. This option is automatically set to true by all `<Def/>`s made inside math mode.
   */
  ensureMath?: boolean;
  /**
   * The Expressions to which the `<R/>` macro should expand when in math mode. This overrides the `b`, `p`, and `c` flags.
   */
  math?: Expressions;
  /**
   * HTML classes to apply to the `<a>` tag of all refs.
   */
  refClass?: Expression[] | Expression;
  /**
   * HTML data attributes to apply to the `<a>` tag of all refs.
   */
  refData?: Record<string, Expression>;
  /**
   * The numbering used for rendering the `<R/>` macro when the `c` flag is set. For references such as "Section 2.3"
   */
  numbering: number[];
  /**
   * DEtails on how to render the numbering of the `<R/>` macro when the `c` flag is set. For references such as "Section 2.3"
   */
  numbering_info: NumberingInfo;
  /**
   * Set this to true to *not* create a preview.
   */
  noPreview?: boolean;
  /**
   * Set this to true to *not* highlight definitions and references on hover, even if there is a preview.
   * When `noPreview` is set to true, then no highlighting occurs anyways.
   */
  noHighlight?: boolean;
  /**
   * Instead of linking to the definition site itself, have the def and its references link elsewhere.
   */
  href?: Expression;
  /**
   * Set this to true to not *display* a preview tooltip when hovering over the *definition* itself.
   */
  noTooltipOnDefHover?: boolean;
  /**
   * Css dependencies to add in all files that reference this def.
   */
  depsCssRef?: StylesheetDependencyInfo[];
  /**
   * Js dependencies to add in all files that reference this def.
   */
  depsJsRef?: ScriptDependencyInfo[];
};

/**
 * Information on how to render numbered references to a category of defs.
 */
export type NumberingInfo = {
  /**
   * How to render the category for the `<Rc/>` macro.
   */
  r: Expression;
  /**
   * How to render the category for the `<Rcb/>` macro.
   */
  rb: Expression;
  /**
   * How to render the plural of the category for the `<Rc/>` macro.
   */
  rs: Expression;
  /**
   * How to render the plural of the category for the `<Rc/>` macro.
   */
  rsb: Expression;
  /**
   * How to render a given numbering.
   */
  render: (ctx: Context, numbering: number[]) => Expression;
};

export type DefProps = DefInfo & {
  /**
   * The name by which to reference this def.
   *
   * Provides the default value for the `r` prop.
   */
  n: string;
  /**
   * The html tag to wrap the definition in. Defaults to `<Dfn>`.
   */
  defTag?: (inner: Expression, id: Expression) => Expression;
  /**
   * Set to true to *not* wrap the children in an a tag at the definition site.
   */
  noLink?: boolean;
  /**
   * HTML classes to apply to the `<a>` tag of the definition.
   */
  defClass?: Expression[] | Expression;
  /**
   * HTML data attributes to apply to the `<a>` tag of the definition.
   */
  defData?: Record<string, Expression>;
  /**
   * Set this to true to not *display* a preview tooltip when hovering over the *definition* itself.
   */
  noTooltipOnDefHover?: boolean;
  /**
   * A preview for this definition. If this is set, then the containing preview
   * scope (if any) will ignore this definition, and the explicit preview is used instead.
   */
  preview?: Expression;
  /**
   * When set, does not actually bind the name. Renders the same output, but modifies no macro state.
   */
  fake?: boolean;
  /**
   * Give the definition and all references a `data-preview-wide` attribute.
   */
  wide?: boolean;
  /**
   * The display text of the definition.
   *
   * Defaults to `r`.
   */
  children?: Expressions;
};

export function Def(props: DefProps): Expression {
  return (
    <impure
      fun={(ctx) => {
        if (!props.fake) {
          addName(ctx, props.n);
        }

        const refData = props.refData ?? {};
        if (props.wide) {
          refData["preview-class"] = "wide";
        }

        const ensureMath = props.ensureMath || isMathMode(ctx);

        const info: DefInfo = { ...props, refData, ensureMath };

        if (!props.fake) {
          defs.addName(ctx, props.n, info);
        }

        const config = getConfig(ctx);

        for (const dep of config.depsCssDef ?? []) {
          dependencyCss(ctx, dep);
        }

        for (const dep of config.depsJsDef ?? []) {
          dependencyJs(ctx, dep);
        }

        const defData = props.defData ?? {};
        if (props.wide) {
          defData["preview-class"] = "wide";
        }

        const tag = linkTag({
          ctx,
          isRef: false,
          name: props.n,
          info,
          classes: props.defClass,
          data: defData,
          children: props.children,
          queryParams: [],
          noLink: props.noLink,
        });

        if (isMathMode(ctx) && props.math) {
          l.warn(
            ctx,
            `Specifying the ${Colors.yellow(`math`)} prop of a ${
              Colors.yellow(`<Def>`)
            } macro inside a ${Colors.yellow(`<M>`)} or ${
              Colors.yellow(`<MM>`)
            } macro has no effect.`,
          );
          l.logGroup(ctx, () => {
            l.warn(ctx, `Name: ${styleName(props.n)}`);
          });
          l.at(ctx);
        }

        let explicitPreviewExp: Expression = "";

        // Register preview.
        if (!props.noPreview && !props.fake) {
          if (props.preview === undefined) {
            registerPreview(ctx, {
              name: props.n,
            });
            addScopeDeps(ctx);
          } else {
            explicitPreviewExp = (
              <omnomnom>
                <PreviewScope>
                  {props.preview}
                  <impure
                    fun={(ctx) => {
                      registerPreview(ctx, {
                        name: props.n,
                      }, true);
                      addScopeDeps(ctx);
                      return "";
                    }}
                  />
                </PreviewScope>
              </omnomnom>
            );
          }
        }

        if (tag === null) {
          return null;
        } else if (isMathMode(ctx)) {
          return (
            <>
              <MId id={props.n}>{tag}</MId>
              {explicitPreviewExp}
            </>
          );
        } else {
          const id = props.n;
          if (props.defTag) {
            return <>{props.defTag(tag, id)}{explicitPreviewExp}</>;
          } else {
            return (
              <>
                <Dfn id={id}>
                  {tag}
                </Dfn>
                {explicitPreviewExp}
              </>
            );
          }
        }
      }}
    />
  );
}

/**
 * Add css and js dependencies to the current scope that are common to all preview pages.
 */
function addScopeDeps(ctx: Context) {
  const config = getConfig(ctx);

  for (const dep of config.depsCssPreview ?? []) {
    previewScopeDependencyCss(ctx, dep, true);
  }

  for (const dep of config.depsJsPreview ?? []) {
    previewScopeDependencyJs(ctx, dep, true);
  }
}

export type ReferenceProps = {
  /**
   * The name to reference.
   */
  n: string;
  /**
   * Whether to pluralise the reference.
   */
  p?: boolean;
  /**
   * Whether the reference occurs at the beginning of a sentence.
   */
  b?: boolean;
  /**
   * When to render a numbered reference (e.g. "Section 2.3") instead of a regular one.
   */
  c?: boolean;
  /**
   * Query parameters to append to the url of the reference.
   */
  queryParams?: [string, string][];
  /**
   * A different id to use in the url of the reference than the one registered at the definition.
   */
  replacementId?: string;
  /**
   * Additional data attributes to add to this reference.
   */
  extraData?: Record<string, Expression>;
  /**
   * If true, do not show a preview when hovering over the reference.
   */
  noPreview?: boolean;
  /**
   * The rendered body of the reference, overwriting the default one.
   */
  children?: Expressions;
};

export function R(
  {
    n,
    p,
    b,
    c,
    children,
    queryParams = [],
    replacementId,
    noPreview,
    extraData,
  }: ReferenceProps,
): Expression {
  return (
    <impure
      fun={(ctx) => {
        const info = defs.getName(ctx, n);
        return linkTag({
          ctx,
          isRef: true,
          name: n,
          info,
          p,
          b,
          c,
          children: children,
          queryParams,
          replacementId,
          noPreview,
          extraData,
        });
      }}
    />
  );
}

// Render a non-c ref.
function renderBasicRef(
  info: DefInfo,
  name: string,
  p?: boolean,
  b?: boolean,
): Expression {
  if (p && b && info.rpb) {
    return info.rpb;
  }

  if (!p && b && info.rb) {
    return info.rb;
  }

  if (p && !b && info.rp) {
    return info.rp;
  }

  function warnNoFormatting(
    ctx: Context,
    flag: string,
    description: string,
  ): Expression {
    l.warn(
      ctx,
      `Tried to reference a name with the ${
        Colors.yellow(`<R/>`)
      } macro and the ${
        Colors.yellow(flag)
      } flag, but no ${description} formatting was registered.`,
    );
    l.logGroup(ctx, () => {
      l.warn(ctx, `Name: ${styleName(name)}`);
      l.warn(
        ctx,
        `Defined at ${
          styleDebuggingInformation(getNameAndDebug(ctx, name)![1])
        }`,
      );
    });
    l.at(ctx);
    return name;
  }

  const pluralisedIfNeeded = p
    ? (
      <map
        fun={(evaled, ctx) => {
          const config = getConfig(ctx);

          if (config.defaultP! === null) {
            return warnNoFormatting(ctx, "p", "plural");
          } else {
            return config.defaultP!(ctx, evaled);
          }
        }}
      >
        {info.r ?? name}
      </map>
    )
    : (info.r ?? name);

  const beginningOfSentencedIfNeeded = b
    ? (
      <map
        fun={(evaled, ctx) => {
          const config = getConfig(ctx);

          if (config.defaultB! === null) {
            return warnNoFormatting(ctx, "b", "beginning-of-sentence");
          } else {
            return config.defaultB!(ctx, evaled);
          }
        }}
      >
        {pluralisedIfNeeded}
      </map>
    )
    : pluralisedIfNeeded;

  return beginningOfSentencedIfNeeded;
}

function linkTag(opts: {
  ctx: Context;
  isRef: boolean;
  name: string;
  info: DefInfo | undefined;
  p?: boolean;
  b?: boolean;
  c?: boolean;
  children?: Expressions;
  classes?: Expression[] | Expression;
  data?: Record<string, Expression>;
  render?: (ctx: Context, numbering: number[]) => Expression;
  queryParams: [string, string][];
  replacementId?: string;
  noPreview?: boolean;
  extraData?: Record<string, Expression>;
  noLink?: boolean;
}): Expression | null {
  // Add dependencies that are required on all pages that contain any refs.
  const config = getConfig(opts.ctx);

  for (const dep of config.depsCssRef ?? []) {
    previewScopeDependencyCss(opts.ctx, dep, true);
  }

  for (const dep of config.depsJsRef ?? []) {
    previewScopeDependencyJs(opts.ctx, dep, true);
  }

  // Add dendencies that are required on all pages that reference `opts.name`.
  if (opts.info !== undefined) {
    for (const dep of opts.info.depsCssRef ?? []) {
      previewScopeDependencyCss(opts.ctx, dep, true);
    }

    for (const dep of opts.info.depsJsRef ?? []) {
      previewScopeDependencyJs(opts.ctx, dep, true);
    }
  }

  if (opts.info === undefined) {
    if (opts.ctx.mustMakeProgress()) {
      l.warn(
        opts.ctx,
        `Could not resolve name ${
          styleName(opts.name)
        }, creating an invalid link.`,
      );
      l.at(opts.ctx);

      if (isMathMode(opts.ctx)) {
        return mathLink({
          url: "#",
          children: `??${opts.name}??`,
        });
      } else {
        return <A href="#" style="color: #ff0000;">??{opts.name}??</A>;
      }
    } else {
      return null;
    }
  }

  let exps: Expressions;
  if (opts.info.math && ((opts.info.ensureMath) || isMathMode(opts.ctx))) {
    // Math mode rendering trumps everything.
    exps = opts.info.math;
  } else if (opts.c) {
    // `c` overrides `p`, so we start with it.
    if (opts.info.numbering === undefined) {
      l.error(
        opts.ctx,
        `Cannot create a numbered reference to a ${
          Colors.yellow(`<Def/>`)
        } without ${Colors.yellow(`numbering`)} information.`,
      );
      l.logGroup(opts.ctx, () => {
        l.error(opts.ctx, `Name: ${styleName(opts.name)}`);
        l.error(
          opts.ctx,
          `Defined at ${
            styleDebuggingInformation(getNameAndDebug(opts.ctx, opts.name)![1])
          }`,
        );
      });
      return opts.ctx.halt();
    }

    const render = opts.render ?? opts.info.numbering_info.render;

    exps = opts.children
      ? [
        <exps x={opts.children} />,
        " ",
        render(opts.ctx, opts.info.numbering),
      ]
      : [
        opts.b ? opts.info.numbering_info.rb : opts.info.numbering_info.r,
        "&nbsp;",
        render(opts.ctx, opts.info.numbering),
      ];
  } else {
    // It is a totally basic reference.
    exps = renderBasicRef(
      opts.info!,
      opts.name,
      opts.p,
      opts.b,
    );
  }

  let data: Record<string, Expression> = {};
  if (opts.isRef) {
    if (opts.info.refData !== undefined) {
      data = { ...opts.info.refData };
    }
  }
  addDataAttributes(
    opts.ctx,
    data!,
    opts.name,
    true,
    !(opts.info.noPreview || opts.noPreview) &&
      (!(opts.info.noTooltipOnDefHover && !opts.isRef)),
    !opts.info.noHighlight,
    opts.queryParams,
    opts.replacementId,
    opts.extraData,
  );

  for (const key in opts.data) {
    data[key] = opts.data[key];
  }

  const refClass = opts.isRef ? opts.info.refClass : undefined;
  const clazz = opts.classes ?? refClass;
  const finalData = data;
  if (isMathMode(opts.ctx)) {
    if (opts.info.math && !opts.info.ensureMath) {
      exps = opts.info.math;
    }
  }
  const children = opts.children && !opts.c ? opts.children : <exps x={exps} />;

  if (isMathMode(opts.ctx) || opts.info.ensureMath) {
    const href = opts.info.href
      ? opts.info.href
      : hrefToName(opts.ctx, opts.name, opts.replacementId);

    if (href === null) {
      if (opts.ctx.mustMakeProgress()) {
        l.warn(
          opts.ctx,
          `Could not resolve name ${
            styleName(opts.name)
          }, creating an invalid link.`,
        );
        l.at(opts.ctx);
        return mathLink({
          url: "#",
          clazz,
          data: finalData,
          children,
          ensureMath: opts.info.ensureMath,
          noLink: opts.noLink,
        });
      } else {
        return null;
      }
    } else {
      return mathLink({
        url: href,
        clazz,
        data: finalData,
        children,
        ensureMath: opts.info.ensureMath,
        noLink: opts.noLink,
      });
    }
  } else {
    if (opts.noLink) {
      return <exps x={children} />;
    } else {
      return (
        <IdA
          clazz={clazz}
          data={finalData}
          name={opts.name}
          children={children}
          replacementId={opts.replacementId}
          forceHref={opts.info.href}
        />
      );
    }
  }
}

function mathLink(
  { clazz, data, url, children, ensureMath, noLink }: {
    url: Expression;
    clazz?: Expression[] | Expression;
    data?: Record<string, Expression>;
    children?: Expressions;
    ensureMath?: boolean;
    noLink?: boolean;
  },
): Expression {
  if (noLink) {
    return ensureMath
      ? (
        <M>
          <exps x={children} />
        </M>
      )
      : <exps x={children} />;
  }

  let exp = <MHref url={url} children={children} />;
  exp = data === undefined ? exp : <MData data={data}>{exp}</MData>;
  exp = clazz === undefined ? exp : <MClass clazz={clazz}>{exp}</MClass>;
  exp = ensureMath ? <M>{exp}</M> : exp;
  return exp;
}

function addDataAttributes(
  ctx: Context,
  data: Record<string, Expression>,
  name: string,
  includeRef: boolean,
  includeAnchor: boolean,
  noHighlight: boolean,
  queryParams: [string, string][],
  replacementId?: string,
  extraData: Record<string, Expression> = {},
) {
  if (includeRef) {
    data.ref = name;
  }

  if (includeAnchor) {
    const previewPath = getPreviewPath(ctx);

    let finalComponent = `${name}.html?def§${
      replacementId === undefined ? name : replacementId
    }`;
    for (const [key, value] of queryParams) {
      finalComponent = `${finalComponent}&${key}§${value}`;
    }

    previewPath.push(finalComponent);

    data["preview-anchor"] = (
      <impure
        fun={(ctx) => {
          return hrefTo(ctx, absoluteOutFsPath(previewPath));
        }}
      />
    );
  }

  if (noHighlight) {
    data["hl"] = "true";
  }

  for (const key in extraData) {
    data[key] = extraData[key];
  }
}
